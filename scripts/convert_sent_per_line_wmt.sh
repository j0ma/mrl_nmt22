#!/bin/bash

# Created by argbash-init v2.8.1
# ARG_OPTIONAL_SINGLE([output-folder])
# ARG_OPTIONAL_BOOLEAN([fi-en])
# ARG_OPTIONAL_BOOLEAN([cs-en])
# ARG_OPTIONAL_BOOLEAN([ignore-wikititles])
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option() {
    local first_option all_short_options='h'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output_folder="./wmt19-data"
_arg_fi_en="off"
_arg_kk_en="off"
_arg_cs_en="off"

print_help() {
    printf '%s\n' "<The general help message of my script>"
    printf 'Usage: %s [--output-folder <arg>] [--(no-)fi-en] [--(no-)kk-en] [--(no-)cs-en] [--(no-)gu-en] [--(no-)lt-en] [--ignore-wikititles] [-h|--help]\n' "$0"
    printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --output-folder)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_output_folder="$2"
            shift
            ;;
        --output-folder=*)
            _arg_output_folder="${_key##--output-folder=}"
            ;;
        --no-fi-en | --fi-en)
            _arg_fi_en="on"
            test "${1:0:5}" = "--no-" && _arg_fi_en="off"
            ;;
        --no-kk-en | --kk-en)
            _arg_kk_en="on"
            test "${1:0:5}" = "--no-" && _arg_kk_en="off"
            ;;
        --no-cs-en | --cs-en)
            _arg_cs_en="on"
            test "${1:0:5}" = "--no-" && _arg_cs_en="off"
            ;;
        --no-gu-en | --gu-en)
            _arg_gu_en="on"
            test "${1:0:5}" = "--no-" && _arg_gu_en="off"
            ;;
        --no-lt-en | --lt-en)
            _arg_lt_en="on"
            test "${1:0:5}" = "--no-" && _arg_lt_en="off"
            ;;
        --ignore-wikititles)
            _arg_ignore_wikititles="on"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

parse_commandline "$@"

fi_train_files=(
    "europarl-v9.fi-en.tsv"
    "en-fi.bicleaner07.tmx"
    "rapid2016.en-fi.tmx"
)
fi_dev_files=(
    "newstest2018-enfi-ref.fi"
    "newstest2018-enfi-src.en"
    "newstest2018-fien-ref.en"
    "newstest2018-fien-src.fi"
)

fi_test_files=(
    "newstest2019-enfi-ref.fi"
    "newstest2019-enfi-src.en"
    "newstest2019-fien-ref.en"
    "newstest2019-fien-src.fi"
)

extract_fi() {
    local raw_data_folder="${_arg_output_folder}/fi-en/raw"
    local interim_data_folder="${_arg_output_folder}/fi-en/interim"
    local output_data_folder="${_arg_output_folder}/fi-en/final"

    # step 0: handling TMX and tsv files
    for f in "${fi_train_files[@]}"; do
        if [ "${f}" = "europarl-v9.fi-en.tsv" ]; then
            cut -f 1 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.fi}"
            cut -f 2 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.en}"
        else
            cat "${raw_data_folder}/train/${f}" |
                python tmx-extract-parallel.py \
                    -b "${f//.tmx/}" -s "en" -t "fi"
        fi
    done
    mv ./*en-fi* "${raw_data_folder}/train/"
    mv ./*rapid2016* "${raw_data_folder}/train/"

    # step 1: concatenate everything together
    for lang in "en" "fi"; do cat ${raw_data_folder}/train/*.${lang} >"${interim_data_folder}/train/train.${lang}"; done

    # step 2: strip extraneous XML
    for f in "${fi_dev_files[@]}"; do
        sgm_to_txt <"${raw_data_folder}/dev/${f}.sgm" >"${raw_data_folder}/dev/${f//.sgm/}"
    done
    for f in "${fi_test_files[@]}"; do
        sgm_to_txt <"${raw_data_folder}/test/${f}.sgm" >"${raw_data_folder}/test/${f//.sgm/}"
    done

    # step 3: concatenate everything together
    for lang in "en" "fi"; do cat ${raw_data_folder}/dev/*.${lang} >"${interim_data_folder}/dev/dev.${lang}"; done
    for lang in "en" "fi"; do cat ${raw_data_folder}/"test"/*.${lang} >"${interim_data_folder}/test/test.${lang}"; done
}


extract_cs() {
    exit
}

sgm_to_txt() {
    grep "^<seg" |
        sed "s/<seg id\=\"[0-9]\+\">//g" |
        sed "s/<\/seg>//g"
}
# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

printf 'Value of --%s: %s\n' 'output-folder' "$_arg_output_folder"
printf "'%s' is %s\\n" 'fi-en' "$_arg_fi_en"
printf "'%s' is %s\\n" 'kk-en' "$_arg_kk_en"
printf "'%s' is %s\\n" 'cs-en' "$_arg_cs_en"
printf "'%s' is %s\\n" 'gu-en' "$_arg_gu_en"
printf "'%s' is %s\\n" 'lt-en' "$_arg_lt_en"

[ "${_arg_fi_en}" = "on" ] && extract_fi "${_arg_output_folder}"
[ "${_arg_kk_en}" = "on" ] && extract_kk "${_arg_output_folder}"
[ "${_arg_cs_en}" = "on" ] && extract_cs "${_arg_output_folder}"
[ "${_arg_gu_en}" = "on" ] && extract_gu "${_arg_output_folder}"
[ "${_arg_lt_en}" = "on" ] && extract_lt "${_arg_output_folder}"

# ] <-- needed because of Argbash
